学习笔记

# 一、数组、链表和跳表

数组存储在内存中的一段连续单元当中，所以查找成本低，但增删的时候需要移动后面所有位，因此时间复杂度为：

操作     | 时间复杂度
-------- | -----
insert  |  o(n)
delete  |  o(n)
prepend | o(1)
append |  o(1)
lookup |  o(1)


 



链表由节点组成基本单元，每个节点由val和next组成，next指向下一个节点的位置。后一个节点的next指向空表示为链表，指向头指针，为循环链表。如果是双向链表，则有两个指针分别指向头和尾，并且每个节点由pre，val，next三部分组成。链表解决了数组增删不便的问题，但查询时间提高了，时间复杂度：

操作     | 时间复杂度
-------- | -----
insert  |  o(1)
delete  |  o(1)
prepend | o(1)
append |  o(1)
lookup |  o(n)


跳表必须是有序的链表，并且存在升的节点，解决了链表查找慢的问题。时间复杂度：

操作     | 时间复杂度
-------- | -----
insert  |  o(1)
delete  |  o(1)
prepend | o(1)
append |  o(1)
lookup |  o(logn)

空间复杂度为o(n)

链表运用于LRU Cache，跳表运用于Redis
<br><br>

# 二、栈和队列

stack：先入后出

操作     | 时间复杂度
-------- | -----
查询  |  o(n)
添加 |  o(1)
删除 | o(1)



queue：先入先出

操作     | 时间复杂度
-------- | -----
查询  |  o(n)
添加 |  o(1)
删除 | o(1)




实际中我们一般并不使用纯粹的栈和队列，而是使用双端队列double-end queue，它的头和尾都可以进行出入



优先队列priority queue 	按照元素的优先级取出，它的时间复杂度：

操作     | 时间复杂度
-------- | -----
查询  |  o(n)
添加 |  o(1)
删除 | o(logn)




它们都是抽象的类型，实际有多种不同的实现方式<br><br>
小技巧：如何查询实际成熟的具体实现代码及用法
比如：搜索栈 stack java 12    最好还是看英文文档<br><br>



# 三、算法题经验总结:

+ 传统思维，人肉递归，自己一个小部分一个小部分的用思维推导，以确保没有错漏……高效正确的方式是，自顶向下设计，先构思，再实现



+ 先划分一个更普遍的范围，实现，然后再考虑更小范围的特殊情况来添加约束。写好几个小的方面实现来实现相同的东西，会增加代码的冗余，很多时候其实可以写更少的主要重复代码，进行很少的修改就能实现

