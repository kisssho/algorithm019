# 一、哈希表、映射、集合的实现与特性

哈希表是将存入的数据通过一个映射函数所返回的值定位到数组中的特定位置的数据结构。它的时间复杂度是：

操作     | 时间复杂度
-------- | -----
search  | o(1)
insert  | o(1)
delete | o(1)


当然，也可能出现两个存储的数据通过映射函数获得的值相同的情况，换句话说，它们映射到相同的数组位置上了，这个叫做哈希碰撞，这种情况一般会在这个位置接入一个链表，将多个数据存储到链表中。如何哈希表设计的不得当，就可能出现一个位置有很多值的情况。所以哈希表的最坏时间复杂度是o(n)

```javascript
 java code
	hashmap:key,value键值对，key不重复

	new HashMap()/new TreeMap()
	map.set(key,value)
	map.get(key)
	map.has(key)
	map.size()
	map.clear()
   
```

```javascript

hashset:value ，不重复
	set.add(value)
	set.delete(value)
	set.hash(value)
	python

```

```javascript
map:字典
	set:{'ffsdaf','fas','asfd'}
```


<br>

# 二、树、二叉树、二叉搜索树的实现和特性


树是一种二维的结果。它的节点同样有val和next，只不过它的next可以不只有一个。链表是树的特殊情况，树是图的特殊情况。二叉树是只有两个叶子节点的树。

树可以用于表示不同状态空间的状态的扩散。

```javascript
代码实现(python code)：

class TreeNode:
	def __init__(self,val):
		self.root = val
		self.left = None
		self.right = None
```
```javascript
 前序遍历（中序、后序同理）：
def preorder(self,root):
	if root:
		self.traverse_path = root.val
		self.preorder(root.left)
		self.preorder(root.right)
```



二叉搜索树满足根节点左边的所有节点都比它小，右边的所有节点都比它大，并且它的节点也同样，以此类推。它的中序遍历是升序遍历。它的时间复杂度都是o(logn),最坏的情况下，相当于链表了。


二叉搜索树的插入和删除都是遍历到与你所插入和删除的数最接近的位置进行的，如果要删除的数不在叶子节点，那么一般会用比它稍大一些的下一个数来代替它的位置



为什么树的面试题解法一般都是递归？
<br>


# 三、堆和二叉堆的实现和特性

堆用于找到一堆数据中的最大值或最小值，根节点最大的叫大顶堆，最小的叫小顶堆

操作     | 时间复杂度
-------- | -----
find-max   | o(1)
delete-max  | o(logn)
insert(create) | o(logn) or o(1)

堆有很多种实现，常见的实现是二叉堆，但它其实是最低效的一种实现方式，仅仅是勉强达到对这个定义的最低要求

二叉堆一定是一个完全二叉树，根节点一定比它的左右子树更大。



二叉堆具体实现一般用数组，假设第一个节点元素索引是0，那么它的左孩子是2i+1，右孩子是2i+2。对于父亲节点则是取整((i-1)/2)，


二叉堆的插入操作：插入只能插到叶子节点左边的一个元素上，不能打破完全二叉树，并且如果它的根节点比它小，那么就和根节点替换，一次类推，直到整个堆的根节点都大于它的子节点。

二叉堆的删除最大操作：删除最顶部的值，然后找到叶子最后一个节点放到顶部位置，再跟它的左右孩子比，跟最大的那个替换位置，重复直到整个堆根节点都大于它的叶子节点
<br>


# 四、图的实现和特性

Graph(V,E)
V  vertex:点

1. 度-入度和出度
2. 点与点之间:连通与否


E  edge:边

1. 有向和无向（单行线）
2. 权重（边长）


图的表示方法还可以是邻接矩阵和邻接表。图又分为有向和无向、有权和无权

